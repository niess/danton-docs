{"files":[{"file":"danton.h","functions":["danton_primary_cb","danton_event_cb","danton_grammage_cb","danton_lock_cb","danton_initialise","danton_finalise","danton_destroy","danton_pem_dry","danton_particle_pdg","danton_particle_index","danton_sampler_create","danton_sampler_update","danton_context_create","danton_context_destroy","danton_run","danton_error_count","danton_error_pop","danton_error_push"],"meta":{},"lines":396}],"functions":{"danton_initialise":{"type":"function","file":"danton.h","line":275,"lineto":276,"args":[{"name":"pdf","type":"const char *","comment":"Path to the PDF tables for ENT, or <code>NULL</code>.\n"},{"name":"lock","type":"danton_lock_cb *","comment":"A locking callback, or <code>NULL</code>.\n"},{"name":"unlock","type":"danton_lock_cb *","comment":"An unlocking callback, or <code>NULL</code>.\n"}],"argline":"const char *pdf, danton_lock_cb *lock, danton_lock_cb *unlock","sig":"const char *::danton_lock_cb *::danton_lock_cb *","return":{"type":"int","comment":"<pre><code>     `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Initialise the DANTON library.</p>\n","comments":"<p class=\"longComment\">Initialise the DANTON library. If no <em>pdf</em> path is provided the CT14 NNLO tables are used, shiped with ENT.</p>\n\n<p class=\"longComment\"><strong>Warning</strong> : for multithreaded usage one <strong>must</strong> provide valid <em>lock</em> and <em>unlock</em> callbacks.</p>\n","group":"danton"},"danton_finalise":{"type":"function","file":"danton.h","line":284,"lineto":284,"args":[],"argline":"","sig":"","return":{"type":"void","comment":null},"description":"<p>Finalise the danton library.</p>\n","comments":"<p class=\"longComment\">Release the memory used by the Physics engines. Note that user created objects, e.g. simulation <em>contexts</em>, are <strong>not</strong> dealocated.</p>\n","group":"danton"},"danton_destroy":{"type":"function","file":"danton.h","line":293,"lineto":293,"args":[{"name":"any","type":"void **","comment":"The address of the object pointer.\n"}],"argline":"void **any","sig":"void **","return":{"type":"void","comment":null},"description":"<p>Properly dealocate a memory flat object.</p>\n","comments":"<p class=\"longComment\">Note that at return the pointer is set to <code>NULL</code>.</p>\n","group":"danton"},"danton_pem_dry":{"type":"function","file":"danton.h","line":298,"lineto":298,"args":[],"argline":"","sig":"","return":{"type":"void","comment":null},"description":"<p>Replace the sea layer of the PEM with Standard Rock.</p>\n","comments":"","group":"pem"},"danton_particle_pdg":{"type":"function","file":"danton.h","line":306,"lineto":306,"args":[{"name":"particle","type":"enum danton_particle","comment":"The DANTON particle index.\n"}],"argline":"enum danton_particle particle","sig":"enum danton_particle","return":{"type":"int","comment":"<pre><code>       The corresponding PDG number.\n</code></pre>\n"},"description":"<p>Get the PDG particle number for a given DANTON particle index.</p>\n","comments":"","group":"particle"},"danton_particle_index":{"type":"function","file":"danton.h","line":314,"lineto":314,"args":[{"name":"pdg","type":"int","comment":"The PDG number.\n"}],"argline":"int pdg","sig":"int","return":{"type":"enum danton_particle","comment":"<pre><code>  The corresponding DANTON index.\n</code></pre>\n"},"description":"<p>Get the DANTON particle index for a given PDG number.</p>\n","comments":"","group":"particle"},"danton_sampler_create":{"type":"function","file":"danton.h","line":320,"lineto":320,"args":[],"argline":"","sig":"","return":{"type":"struct danton_sampler *","comment":"A handle for the sampler or <code>NULL</code> on failure.\n"},"description":"<p>Create a particle sampler.</p>\n","comments":"","group":"sampler"},"danton_sampler_update":{"type":"function","file":"danton.h","line":330,"lineto":330,"args":[{"name":"sampler","type":"struct danton_sampler *","comment":"The handler for the particle sampler.\n"}],"argline":"struct danton_sampler *sampler","sig":"struct danton_sampler *","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Update a particle sampler according to its current settings.</p>\n","comments":"<p class=\"longComment\">Note that a sampler must be updated <strong>before</strong> it can be used.</p>\n","group":"sampler"},"danton_context_create":{"type":"function","file":"danton.h","line":341,"lineto":341,"args":[],"argline":"","sig":"","return":{"type":"struct danton_context *","comment":"A handle for the context or <code>NULL</code> on failure.\n"},"description":"<p>Create a simulation context.</p>\n","comments":"<p class=\"longComment\">The simulation context is initialised empty. It <strong>must</strong> be assigned a <em>sampler</em> and a <em>recorder</em>. For Monte-Carlo runs a <em>primary</em> flux model is also required.</p>\n","group":"context"},"danton_context_destroy":{"type":"function","file":"danton.h","line":351,"lineto":351,"args":[{"name":"context","type":"struct danton_context **","comment":"A handle for the context.\n"}],"argline":"struct danton_context **context","sig":"struct danton_context **","return":{"type":"void","comment":null},"description":"<p>Destroy a simulation context.</p>\n","comments":"<p class=\"longComment\">This function must be used instead of <a href=\"./#v0.1.1/group/danton/danton_destroy\">danton_destroy</a> in order to properly destroy a simulation context.</p>\n","group":"context"},"danton_run":{"type":"function","file":"danton.h","line":363,"lineto":363,"args":[{"name":"context","type":"struct danton_context *","comment":"The simulation context to use.\n"},{"name":"events","type":"long","comment":"The number of Monte-carlo events or scan points.\n"}],"argline":"struct danton_context *context, long events","sig":"struct danton_context *::long","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Run a Monte-Carlo simulation or a grammage scan.</p>\n","comments":"<p class=\"longComment\">Depending on the context <em>mode</em> a Monte-Carlo simulation or a grammage scan is done.</p>\n","group":"danton"},"danton_error_count":{"type":"function","file":"danton.h","line":373,"lineto":373,"args":[{"name":"context","type":"struct danton_context *","comment":"The context of interest or <code>NULL</code>.\n"}],"argline":"struct danton_context *context","sig":"struct danton_context *","return":{"type":"int","comment":"<pre><code>      The corresponding error count.\n</code></pre>\n"},"description":"<p>Get the current number of unprocessed errors.</p>\n","comments":"<p class=\"longComment\">If no <em>context</em> is provided the number of global errors is returned.</p>\n","group":"error"},"danton_error_pop":{"type":"function","file":"danton.h","line":383,"lineto":383,"args":[{"name":"context","type":"struct danton_context *","comment":"The context of interest or <code>NULL</code>.\n"}],"argline":"struct danton_context *context","sig":"struct danton_context *","return":{"type":"const char *","comment":"<pre><code>      A string describing the last error.\n</code></pre>\n"},"description":"<p>Retrieve the last error in the stack.</p>\n","comments":"<p class=\"longComment\">If no <em>context</em> is provided the error is taken from the global stack.</p>\n","group":"error"},"danton_error_push":{"type":"function","file":"danton.h","line":395,"lineto":396,"args":[{"name":"context","type":"struct danton_context *","comment":"The context where the error occurred or <code>NULL</code>.\n"},{"name":"format","type":"const char *","comment":"A format string for the error message.\n"}],"argline":"struct danton_context *context, const char *format","sig":"struct danton_context *::const char *","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Append an error message to the stack.</p>\n","comments":"<p class=\"longComment\">The format string and variable arguments follow the printf syntax.</p>\n","group":"error"}},"callbacks":{"danton_primary_cb":{"type":"callback","file":"danton.h","line":66,"lineto":67,"args":[{"name":"primary","type":"struct danton_primary *","comment":"Handle for the primary data.\n"},{"name":"energy","type":"double","comment":"The energy of the primary neutrino, in GeV.\n"}],"argline":"struct danton_primary *primary, double energy","sig":"struct danton_primary *::double","return":{"type":"double","comment":"<pre><code>      The corresponding flux.\n</code></pre>\n"},"description":"<p>Callback for a primary neutrino flux.</p>\n","comments":""},"danton_event_cb":{"type":"callback","file":"danton.h","line":164,"lineto":165,"args":[{"name":"context","type":"struct danton_context *","comment":"Handle for the simulation context.\n"},{"name":"recorder","type":"struct danton_recorder *","comment":"Handle for the recorder data.\n"},{"name":"event","type":"const struct danton_event *","comment":"Handle for the event data.\n"}],"argline":"struct danton_context *context, struct danton_recorder *recorder, const struct danton_event *event","sig":"struct danton_context *::struct danton_recorder *::const struct danton_event *","return":{"type":"int","comment":"<pre><code>       `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Callback for recording a sampled event.</p>\n","comments":""},"danton_grammage_cb":{"type":"callback","file":"danton.h","line":174,"lineto":175,"args":[{"name":"context","type":"struct danton_context *","comment":"Handle for the simulation context.\n"},{"name":"recorder","type":"struct danton_recorder *","comment":"Handle for the recorder data.\n"},{"name":"grammage","type":"const struct danton_grammage *","comment":"Handle for the grammage data.\n"}],"argline":"struct danton_context *context, struct danton_recorder *recorder, const struct danton_grammage *grammage","sig":"struct danton_context *::struct danton_recorder *::const struct danton_grammage *","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Callback for recording a grammage value.</p>\n","comments":""},"danton_lock_cb":{"type":"callback","file":"danton.h","line":259,"lineto":259,"args":[],"argline":"","sig":"","return":{"type":"int","comment":"<code>EXIT_SUCCESS</code> on success, <code>EXIT_FAILURE</code> otherwise.\n"},"description":"<p>Generic lock or unlock callback.</p>\n","comments":"<p class=\"longComment\">For multithreaded usage the user must supply a pair of lock and unlock callbacks ensuring exclusive access to critical data by the simulation contexts.</p>\n"}},"globals":{},"types":[["danton_context",{"decl":["enum danton_mode mode","int longitudinal","int decay","struct danton_primary *[6] primary","struct danton_sampler * sampler","struct danton_recorder * recorder"],"type":"struct","value":"danton_context","file":"danton.h","line":207,"lineto":248,"tdef":null,"description":" Handle for a simulation context.","comments":"<p class=\"longComment\">This structure is a proxy to thread specific simulation data. It exposes some public data that the user may configure or alter directly. However, it also encloses other opaque data. Therefore, it <strong>must</strong> be initialised and released with the <code>danton_context</code> functions.</p>\n","fields":[{"type":"enum danton_mode","name":"mode","comments":"The run mode. \n"},{"type":"int","name":"longitudinal","comments":"Flag for controlling the tranverse transport.\n\nSet this flag to <code>1</code> in order to disable tranverse transport, i.e.\n force straight trajectories. By default the transverse transport is\n enabled.\n"},{"type":"int","name":"decay","comments":"Flag for controlling the decay of tau final states.\n\nSet this flag to <code>1</code> if the sampled tau final states must be decayed.\n By default the taus are decayed.\n"},{"type":"struct danton_primary *[6]","name":"primary","comments":"Array of pointers to the primary flux models for each neutrino\n flavour.\n\nSet an entry to <code>ǸULL</code> in order to disable the corresponding\n neutrino as a primary. <strong>Note</strong> that in Monte-Carlo modes (Forward,\n or Backward) at least one entry <strong>must</strong> be non `ǸULL.\n"},{"type":"struct danton_sampler *","name":"sampler","comments":"Handle for the event sampler.\n\nStarts initialised to <code>ǸULL</code>. One must provide a sampler before\n running.\n"},{"type":"struct danton_recorder *","name":"recorder","comments":"Handle for the event recorder.\n\nStarts initialised to <code>ǸULL</code>. One must provide a recorder before\n running.\n"}],"block":"enum danton_mode mode\nint longitudinal\nint decay\nstruct danton_primary *[6] primary\nstruct danton_sampler * sampler\nstruct danton_recorder * recorder","used":{"returns":["danton_context_create"],"needs":["danton_context_destroy","danton_error_count","danton_error_pop","danton_error_push","danton_event_cb","danton_grammage_cb","danton_run"]}}],["danton_event",{"decl":["long id","double weight","struct danton_state * primary","int generation","struct danton_state * vertex","struct danton_state * final","int n_products","struct danton_product * product"],"type":"struct","value":"danton_event","file":"danton.h","line":124,"lineto":145,"block":"long id\ndouble weight\nstruct danton_state * primary\nint generation\nstruct danton_state * vertex\nstruct danton_state * final\nint n_products\nstruct danton_product * product","tdef":null,"description":" Data container for exposing a recorded event. ","comments":"","fields":[{"type":"long","name":"id","comments":"The Monte-Carlo index of the event. \n"},{"type":"double","name":"weight","comments":"The Monte-Carlo weight for the event. \n"},{"type":"struct danton_state *","name":"primary","comments":"Pointer to the primary state. \n"},{"type":"int","name":"generation","comments":"The generation index of the recorded tau. An index &gt; 1 indicates\n that the tau originates from a regenerated neutrino, not from a\n primary one.\n"},{"type":"struct danton_state *","name":"vertex","comments":"Pointer to the tau state at its creation vertex. \n"},{"type":"struct danton_state *","name":"final","comments":"Pointer to the final particle state, before decay for taus. \n"},{"type":"int","name":"n_products","comments":"The number of decay products. \n"},{"type":"struct danton_product *","name":"product","comments":"Array of decay products. \n"}],"used":{"returns":[],"needs":["danton_event_cb"]}}],["danton_grammage",{"decl":["double elevation","double value"],"type":"struct","value":"danton_grammage","file":"danton.h","line":148,"lineto":153,"block":"double elevation\ndouble value","tdef":null,"description":" Data container for exposing a grammage computation. ","comments":"","fields":[{"type":"double","name":"elevation","comments":"The elevation angle of observation, in deg. \n"},{"type":"double","name":"value","comments":"The corresponding grammage value, in kg/m<sup>3.</sup> \n"}],"used":{"returns":[],"needs":["danton_grammage_cb"]}}],["danton_mode",{"decl":["DANTON_MODE_BACKWARD","DANTON_MODE_FORWARD","DANTON_MODE_GRAMMAGE","DANTON_MODE_N"],"type":"enum","file":"danton.h","line":189,"lineto":198,"block":"DANTON_MODE_BACKWARD\nDANTON_MODE_FORWARD\nDANTON_MODE_GRAMMAGE\nDANTON_MODE_N","tdef":null,"description":" The available run modes. ","comments":"","fields":[{"type":"int","name":"DANTON_MODE_BACKWARD","comments":"<p class=\"longComment\">Backward Monte-Carlo simulation. </p>\n","value":0},{"type":"int","name":"DANTON_MODE_FORWARD","comments":"<p class=\"longComment\">Classical forward Monte-Carlo. </p>\n","value":1},{"type":"int","name":"DANTON_MODE_GRAMMAGE","comments":"<p class=\"longComment\">Grammage computation. </p>\n","value":2},{"type":"int","name":"DANTON_MODE_N","comments":"<p class=\"longComment\">The total number of run modes. </p>\n","value":3}],"used":{"returns":[],"needs":[]}}],["danton_particle",{"decl":["DANTON_PARTICLE_UNKNOWN","DANTON_PARTICLE_NU_BAR_TAU","DANTON_PARTICLE_NU_BAR_MU","DANTON_PARTICLE_NU_BAR_E","DANTON_PARTICLE_NU_E","DANTON_PARTICLE_NU_MU","DANTON_PARTICLE_NU_TAU","DANTON_PARTICLE_N_NU","DANTON_PARTICLE_TAU_BAR","DANTON_PARTICLE_TAU","DANTON_PARTICLE_N"],"type":"enum","file":"danton.h","line":33,"lineto":56,"block":"DANTON_PARTICLE_UNKNOWN\nDANTON_PARTICLE_NU_BAR_TAU\nDANTON_PARTICLE_NU_BAR_MU\nDANTON_PARTICLE_NU_BAR_E\nDANTON_PARTICLE_NU_E\nDANTON_PARTICLE_NU_MU\nDANTON_PARTICLE_NU_TAU\nDANTON_PARTICLE_N_NU\nDANTON_PARTICLE_TAU_BAR\nDANTON_PARTICLE_TAU\nDANTON_PARTICLE_N","tdef":null,"description":" Indices of DANTON particles. ","comments":"","fields":[{"type":"int","name":"DANTON_PARTICLE_UNKNOWN","comments":"","value":-1},{"type":"int","name":"DANTON_PARTICLE_NU_BAR_TAU","comments":"<p class=\"longComment\">The anti tau neutrino. </p>\n","value":0},{"type":"int","name":"DANTON_PARTICLE_NU_BAR_MU","comments":"<p class=\"longComment\">The anti muon neutrino. </p>\n","value":1},{"type":"int","name":"DANTON_PARTICLE_NU_BAR_E","comments":"<p class=\"longComment\">The anti electron neutrino. </p>\n","value":2},{"type":"int","name":"DANTON_PARTICLE_NU_E","comments":"<p class=\"longComment\">The electron neutrino. </p>\n","value":3},{"type":"int","name":"DANTON_PARTICLE_NU_MU","comments":"<p class=\"longComment\">The muon neutrino. </p>\n","value":4},{"type":"int","name":"DANTON_PARTICLE_NU_TAU","comments":"<p class=\"longComment\">The tau neutrino. </p>\n","value":5},{"type":"int","name":"DANTON_PARTICLE_N_NU","comments":"<p class=\"longComment\">The total number of neutrino indices. </p>\n","value":6},{"type":"int","name":"DANTON_PARTICLE_TAU_BAR","comments":"<p class=\"longComment\">The anti tau. </p>\n","value":6},{"type":"int","name":"DANTON_PARTICLE_TAU","comments":"<p class=\"longComment\">The tau. </p>\n","value":7},{"type":"int","name":"DANTON_PARTICLE_N","comments":"<p class=\"longComment\">The total number of indices. </p>\n","value":8}],"used":{"returns":["danton_particle_index"],"needs":["danton_particle_pdg"]}}],["danton_primary",{"decl":["danton_primary_cb * flux","double [2] energy"],"type":"struct","value":"danton_primary","file":"danton.h","line":75,"lineto":80,"tdef":null,"description":" Base data for a primary flux model.","comments":"<p class=\"longComment\">This is the minimalistic representation of a primary neutrino flux. Any model implementation should conform to this.</p>\n","fields":[{"type":"danton_primary_cb *","name":"flux","comments":"The primary flux callback. \n"},{"type":"double [2]","name":"energy","comments":"The energy range over which the model is defined, in GeV. \n"}],"block":"danton_primary_cb * flux\ndouble [2] energy","used":{"returns":[],"needs":["danton_primary_cb"]}}],["danton_product",{"decl":["int pid","double [3] momentum"],"type":"struct","value":"danton_product","file":"danton.h","line":116,"lineto":121,"block":"int pid\ndouble [3] momentum","tdef":null,"description":" Data container for a tau decay product. ","comments":"","fields":[{"type":"int","name":"pid","comments":"The PDG ID of the daughter. \n"},{"type":"double [3]","name":"momentum","comments":"The 3-momentum of the daughter, in GeV/c. \n"}],"used":{"returns":[],"needs":[]}}],["danton_recorder",{"decl":["danton_event_cb * record_event","danton_grammage_cb * record_grammage"],"type":"struct","value":"danton_recorder","file":"danton.h","line":183,"lineto":186,"tdef":null,"description":" Base data for recording the sampled events or grammage computations.","comments":"<p class=\"longComment\">This is the minimalistic representation of an event recorder. Any concrete implementation should conform to this.</p>\n","fields":[{"type":"danton_event_cb *","name":"record_event","comments":""},{"type":"danton_grammage_cb *","name":"record_grammage","comments":""}],"block":"danton_event_cb * record_event\ndanton_grammage_cb * record_grammage","used":{"returns":[],"needs":["danton_event_cb","danton_grammage_cb"]}}],["danton_sampler",{"decl":["double [2] altitude","double [2] elevation","double [2] energy","double [8] weight"],"type":"struct","value":"danton_sampler","file":"danton.h","line":89,"lineto":101,"block":"double [2] altitude\ndouble [2] elevation\ndouble [2] energy\ndouble [8] weight","tdef":null,"description":" Data container for an event sampler.","comments":"<p class=\"longComment\">This structure specifies the final state of the events to sample. Once filled one <strong>must</strong> call <a href=\"./#v0.1.1/group/sampler/danton_sampler_update\">danton_sampler_update</a> for the sampler to be ready to use.</p>\n","fields":[{"type":"double [2]","name":"altitude","comments":"The altitude range over which events are sampled, in m. \n"},{"type":"double [2]","name":"elevation","comments":"The elevation angle range of the final state, in deg. \n"},{"type":"double [2]","name":"energy","comments":"The energy range of the final state, in GeV. \n"},{"type":"double [8]","name":"weight","comments":"A weight vector specifying the sampling probabilities, in [0,1],\n for all particles.\n"}],"used":{"returns":["danton_sampler_create"],"needs":["danton_sampler_update"]}}],["danton_state",{"decl":["int pid","double energy","double [3] position","double [3] direction"],"type":"struct","value":"danton_state","file":"danton.h","line":104,"lineto":113,"block":"int pid\ndouble energy\ndouble [3] position\ndouble [3] direction","tdef":null,"description":" Data container for a recorded particle state. ","comments":"","fields":[{"type":"int","name":"pid","comments":"The PDG ID of the recorded particle.  \n"},{"type":"double","name":"energy","comments":"The total energy of the recorded particle, in GeV. \n"},{"type":"double [3]","name":"position","comments":"The ECEF position of the recorded particle, in m. \n"},{"type":"double [3]","name":"direction","comments":"The momentum&#39;s direction of the recorded particle, in ECEF frame. \n"}],"used":{"returns":[],"needs":[]}}]],"prefix":"include","groups":[["context",["danton_context_create","danton_context_destroy"]],["danton",["danton_destroy","danton_finalise","danton_initialise","danton_run"]],["error",["danton_error_count","danton_error_pop","danton_error_push"]],["particle",["danton_particle_index","danton_particle_pdg"]],["pem",["danton_pem_dry"]],["sampler",["danton_sampler_create","danton_sampler_update"]]]}