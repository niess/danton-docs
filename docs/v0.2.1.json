{"files":[{"file":"danton.h","functions":["danton_primary_cb","danton_event_cb","danton_grammage_cb","danton_run_cb","danton_lock_cb","danton_initialise","danton_finalise","danton_destroy","danton_earth_model","danton_get_datum","danton_get_uniform01","danton_particle_pdg","danton_particle_index","danton_sampler_create","danton_sampler_update","danton_context_create","danton_context_destroy","danton_run","danton_error_count","danton_error_pop","danton_error_push"],"meta":{},"lines":492},{"file":"danton/primary/discrete.h","functions":["danton_discrete_create","danton_discrete_set","danton_discrete_get","danton_discrete_check"],"meta":{},"lines":74},{"file":"danton/primary/powerlaw.h","functions":["danton_powerlaw_create","danton_powerlaw_check"],"meta":{},"lines":67},{"file":"danton/recorder/text.h","functions":["danton_text_create","danton_text_check"],"meta":{},"lines":71}],"functions":{"danton_initialise":{"type":"function","file":"danton.h","line":313,"lineto":314,"args":[{"name":"pdf","type":"const char *","comment":"Path to the PDF tables for ENT, or <code>NULL</code>.\n"},{"name":"mdf","type":"const char *","comment":"Path to the MDF file for PUMAS, or <code>NULL</code>.\n"},{"name":"dedx","type":"const char *","comment":"Path to the energy loss tables for PUMAS, or <code>NULL</code>.\n"},{"name":"lock","type":"danton_lock_cb *","comment":"A locking callback, or <code>NULL</code>.\n"},{"name":"unlock","type":"danton_lock_cb *","comment":"An unlocking callback, or <code>NULL</code>.\n"}],"argline":"const char *pdf, const char *mdf, const char *dedx, danton_lock_cb *lock, danton_lock_cb *unlock","sig":"const char *::const char *::const char *::danton_lock_cb *::danton_lock_cb *","return":{"type":"int","comment":"<pre><code>     `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Initialise the DANTON library.</p>\n","comments":"<p class=\"longComment\">Initialise the DANTON library. If no <em>pdf</em> path is provided the CT14 NNLO tables are used, shiped with ENT.</p>\n\n<p class=\"longComment\"><strong>Warning</strong> : for multithreaded usage one <strong>must</strong> provide valid <em>lock</em> and <em>unlock</em> callbacks.</p>\n","group":"danton"},"danton_finalise":{"type":"function","file":"danton.h","line":322,"lineto":322,"args":[],"argline":"","sig":"","return":{"type":"void","comment":null},"description":"<p>Finalise the danton library.</p>\n","comments":"<p class=\"longComment\">Release the memory used by the Physics engines. Note that user created objects, e.g. simulation <em>contexts</em>, are <strong>not</strong> dealocated.</p>\n","group":"danton"},"danton_destroy":{"type":"function","file":"danton.h","line":331,"lineto":331,"args":[{"name":"any","type":"void **","comment":"The address of the object pointer.\n"}],"argline":"void **any","sig":"void **","return":{"type":"void","comment":null},"description":"<p>Properly dealocate a memory flat object.</p>\n","comments":"<p class=\"longComment\">Note that at return the pointer is set to <code>NULL</code>.</p>\n","group":"danton"},"danton_earth_model":{"type":"function","file":"danton.h","line":369,"lineto":371,"args":[{"name":"geodesic","type":"const char *","comment":"The reference geodesic model, or <code>ǸULL</code>.\n"},{"name":"topography","type":"const char *","comment":"Topography model, path to any topographic data, or <code>ǸULL</code>.\n"},{"name":"stack_size","type":"int","comment":"The stack size for tiles when using a detailed topography.\n"},{"name":"material","type":"const char *","comment":"Material for the topography.\n"},{"name":"density","type":"double","comment":"Density of the topography material in kg / m<sup>3.</sup>\n"},{"name":"sea","type":"int *","comment":"Pointer to a flag to enable or disable sea(s), or <code>NULL</code>.\n"}],"argline":"const char *geodesic, const char *topography, int stack_size, const char *material, double density, int *sea","sig":"const char *::const char *::int::const char *::double::int *","return":{"type":"int","comment":"<pre><code>       `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Set or update the global Earth model.</p>\n","comments":"<p class=\"longComment\"><strong>Warning</strong> : this function is <strong>not</strong> thread safe. It sets the Earth model globally.</p>\n\n<p class=\"longComment\">The default Earth model is the Preliminary Reference Earth Model, i.e. a spherical Earth fully covered with a 3km deep sea.</p>\n\n<p class=\"longComment\">The supported <em>geodesic</em> values are:   - PREM (spherical)   - WGS84 (GPS ellipsoid)</p>\n\n<p class=\"longComment\">The <em>topography</em> parameter can either specify a path to topographic data (ASTER-GDEM2 compatible tiles) or encode a flat topography as <code>flat://${z}</code>, where <code>${z}</code> is the constant altitude above sea level, in meters, e.g. <code>flat://1000</code> for a 1km high cover.</p>\n\n<p class=\"longComment\"><strong>Note</strong> : specifying a detailed topography requires the WGS 84 geodetic system to be used.</p>\n\n<p class=\"longComment\">The topography <em>material</em> must match one of the materials defined in the xml PUMAS Materials Definition File (MDF). If <code>NULL</code> is given the material is left unchanged. It defaults to Rock.</p>\n\n<p class=\"longComment\">If a null or negative density is provided the material density is left unchanged. It defaults to 2.65 g / cm<sup>3.</sup></p>\n","group":"earth"},"danton_get_datum":{"type":"function","file":"danton.h","line":384,"lineto":384,"args":[],"argline":"","sig":"","return":{"type":"void *","comment":"A <code>turtle_datum</code> pointer, or <code>NULL</code>.\n"},"description":"<p>Get the current topography datum.</p>\n","comments":"<p class=\"longComment\">This routines provides access to the low level <code>turtle_datum</code> used by DANTON for handling the topography. It can be used, e.g. for performing coordinate transforms or querying the altitude with TURTLE.</p>\n\n<p class=\"longComment\"><strong>Warnings</strong> : the datum should not be modified directly with TURTLE. Use the DANTON API functions instead.</p>\n","group":"get"},"danton_get_uniform01":{"type":"function","file":"danton.h","line":391,"lineto":391,"args":[{"name":"context","type":"struct danton_context *","comment":"A simulation context or <code>NULL</code>.\n"}],"argline":"struct danton_context *context","sig":"struct danton_context *","return":{"type":"double","comment":"<pre><code>     A pseudo random number in [0,1], uniformly.\n</code></pre>\n"},"description":"<p>Get a random number from DANTON&#39;s stream.</p>\n","comments":"","group":"get"},"danton_particle_pdg":{"type":"function","file":"danton.h","line":399,"lineto":399,"args":[{"name":"particle","type":"enum danton_particle","comment":"The DANTON particle index.\n"}],"argline":"enum danton_particle particle","sig":"enum danton_particle","return":{"type":"int","comment":"<pre><code>       The corresponding PDG number.\n</code></pre>\n"},"description":"<p>Get the PDG particle number for a given DANTON particle index.</p>\n","comments":"","group":"particle"},"danton_particle_index":{"type":"function","file":"danton.h","line":407,"lineto":407,"args":[{"name":"pdg","type":"int","comment":"The PDG number.\n"}],"argline":"int pdg","sig":"int","return":{"type":"enum danton_particle","comment":"<pre><code>  The corresponding DANTON index.\n</code></pre>\n"},"description":"<p>Get the DANTON particle index for a given PDG number.</p>\n","comments":"","group":"particle"},"danton_sampler_create":{"type":"function","file":"danton.h","line":413,"lineto":413,"args":[],"argline":"","sig":"","return":{"type":"struct danton_sampler *","comment":"A handle for the sampler or <code>NULL</code> on failure.\n"},"description":"<p>Create a particle sampler.</p>\n","comments":"","group":"sampler"},"danton_sampler_update":{"type":"function","file":"danton.h","line":423,"lineto":423,"args":[{"name":"sampler","type":"struct danton_sampler *","comment":"The handler for the particle sampler.\n"}],"argline":"struct danton_sampler *sampler","sig":"struct danton_sampler *","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Update a particle sampler according to its current settings.</p>\n","comments":"<p class=\"longComment\">Note that a sampler must be updated <strong>before</strong> it can be used.</p>\n","group":"sampler"},"danton_context_create":{"type":"function","file":"danton.h","line":434,"lineto":434,"args":[],"argline":"","sig":"","return":{"type":"struct danton_context *","comment":"A handle for the context or <code>NULL</code> on failure.\n"},"description":"<p>Create a simulation context.</p>\n","comments":"<p class=\"longComment\">The simulation context is initialised empty. It <strong>must</strong> be assigned a <em>sampler</em> and a <em>recorder</em>. For Monte-Carlo runs a <em>primary</em> flux model is also required.</p>\n","group":"context"},"danton_context_destroy":{"type":"function","file":"danton.h","line":444,"lineto":444,"args":[{"name":"context","type":"struct danton_context **","comment":"A handle for the context.\n"}],"argline":"struct danton_context **context","sig":"struct danton_context **","return":{"type":"void","comment":null},"description":"<p>Destroy a simulation context.</p>\n","comments":"<p class=\"longComment\">This function must be used instead of <a href=\"./#v0.2.1/group/danton/danton_destroy\">danton_destroy</a> in order to properly destroy a simulation context.</p>\n","group":"context"},"danton_run":{"type":"function","file":"danton.h","line":458,"lineto":459,"args":[{"name":"context","type":"struct danton_context *","comment":"The simulation context to use.\n"},{"name":"events","type":"long","comment":"The maximum number of Monte-carlo events or scan points.\n"},{"name":"requested","type":"long","comment":"The number of requested events to log.\n"}],"argline":"struct danton_context *context, long events, long requested","sig":"struct danton_context *::long::long","return":{"type":"int","comment":"<pre><code>          `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Run a Monte-Carlo simulation or a grammage scan.</p>\n","comments":"<p class=\"longComment\">Depending on the context <em>mode</em> a Monte-Carlo simulation or a grammage scan is done. Note that setting <em>requested</em> to zero or less ignores this option, resulting in all events to be processed.</p>\n","group":"danton"},"danton_error_count":{"type":"function","file":"danton.h","line":469,"lineto":469,"args":[{"name":"context","type":"struct danton_context *","comment":"The context of interest or <code>NULL</code>.\n"}],"argline":"struct danton_context *context","sig":"struct danton_context *","return":{"type":"int","comment":"<pre><code>      The corresponding error count.\n</code></pre>\n"},"description":"<p>Get the current number of unprocessed errors.</p>\n","comments":"<p class=\"longComment\">If no <em>context</em> is provided the number of global errors is returned.</p>\n","group":"error"},"danton_error_pop":{"type":"function","file":"danton.h","line":479,"lineto":479,"args":[{"name":"context","type":"struct danton_context *","comment":"The context of interest or <code>NULL</code>.\n"}],"argline":"struct danton_context *context","sig":"struct danton_context *","return":{"type":"const char *","comment":"<pre><code>      A string describing the last error.\n</code></pre>\n"},"description":"<p>Retrieve the last error in the stack.</p>\n","comments":"<p class=\"longComment\">If no <em>context</em> is provided the error is taken from the global stack.</p>\n","group":"error"},"danton_error_push":{"type":"function","file":"danton.h","line":491,"lineto":492,"args":[{"name":"context","type":"struct danton_context *","comment":"The context where the error occurred or <code>NULL</code>.\n"},{"name":"format","type":"const char *","comment":"A format string for the error message.\n"}],"argline":"struct danton_context *context, const char *format","sig":"struct danton_context *::const char *","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Append an error message to the stack.</p>\n","comments":"<p class=\"longComment\">The format string and variable arguments follow the printf syntax.</p>\n","group":"error"},"danton_discrete_create":{"type":"function","file":"danton/primary/discrete.h","line":44,"lineto":45,"args":[{"name":"energy","type":"double","comment":"The energy of the primary neutrino, in GeV.\n"},{"name":"weight","type":"double","comment":"The intensity of the discrete source.\n"}],"argline":"double energy, double weight","sig":"double::double","return":{"type":"struct danton_discrete *","comment":"<pre><code>      The corresponding discrete danton_primary, or `ǸULL`.\n</code></pre>\n"},"description":"<p>Create a discrete danton_primary.</p>\n","comments":"","group":"discrete"},"danton_discrete_set":{"type":"function","file":"danton/primary/discrete.h","line":55,"lineto":56,"args":[{"name":"discrete","type":"struct danton_discrete *","comment":"The discrete danton_primary.\n"},{"name":"energy","type":"double","comment":"The energy of the primary neutrino, in GeV.\n"},{"name":"weight","type":"double","comment":"The intensity of the discrete source.\n"}],"argline":"struct danton_discrete *discrete, double energy, double weight","sig":"struct danton_discrete *::double::double","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Set the properties of a discrete danton_primary.</p>\n","comments":"","group":"discrete"},"danton_discrete_get":{"type":"function","file":"danton/primary/discrete.h","line":65,"lineto":66,"args":[{"name":"discrete","type":"const struct danton_discrete *","comment":"The discrete danton_primary.\n"},{"name":"energy","type":"double *","comment":"The energy of the primary neutrino, in GeV.\n"},{"name":"weight","type":"double *","comment":"The intensity of the discrete source.\n"}],"argline":"const struct danton_discrete *discrete, double *energy, double *weight","sig":"const struct danton_discrete *::double *::double *","return":{"type":"void","comment":null},"description":"<p>Get the properties of a discrete danton_primary.</p>\n","comments":"","group":"discrete"},"danton_discrete_check":{"type":"function","file":"danton/primary/discrete.h","line":74,"lineto":74,"args":[{"name":"primary","type":"struct danton_primary *","comment":"The danton_primary.\n"}],"argline":"struct danton_primary *primary","sig":"struct danton_primary *","return":{"type":"int","comment":"<pre><code>     `1` if the primary is a discrete one, `0` otherwise.\n</code></pre>\n"},"description":"<p>Check if a danton_primary is of <em>discrete</em> type.</p>\n","comments":"","group":"discrete"},"danton_powerlaw_create":{"type":"function","file":"danton/primary/powerlaw.h","line":58,"lineto":59,"args":[{"name":"energy_min","type":"double","comment":"The minimum energy of the primary neutrino, in GeV.\n"},{"name":"energy_max","type":"double","comment":"The maximum energy of the primary neutrino, in GeV.\n"},{"name":"exponent","type":"double","comment":"The exponent of the powerlaw.\n"},{"name":"weight","type":"double","comment":"The intensity of the powerlaw source.\n"}],"argline":"double energy_min, double energy_max, double exponent, double weight","sig":"double::double::double::double","return":{"type":"struct danton_powerlaw *","comment":"<pre><code>          The corresponding powerlaw danton_primary, or `ǸULL`.\n</code></pre>\n"},"description":"<p>Create a powerlaw danton_primary.</p>\n","comments":"","group":"powerlaw"},"danton_powerlaw_check":{"type":"function","file":"danton/primary/powerlaw.h","line":67,"lineto":67,"args":[{"name":"primary","type":"struct danton_primary *","comment":"The danton_primary.\n"}],"argline":"struct danton_primary *primary","sig":"struct danton_primary *","return":{"type":"int","comment":"<pre><code>     `1` if the primary is a powerlaw one, `0` otherwise.\n</code></pre>\n"},"description":"<p>Check if a danton_primary is of <em>powerlaw</em> type.</p>\n","comments":"","group":"powerlaw"},"danton_text_create":{"type":"function","file":"danton/recorder/text.h","line":63,"lineto":63,"args":[{"name":"path","type":"const char *","comment":"The path to the text file\n"}],"argline":"const char *path","sig":"const char *","return":{"type":"struct danton_text *","comment":"<pre><code>   The corresponding text danton_recorder, or `ǸULL`.\n</code></pre>\n"},"description":"<p>Create a text danton_recorder.</p>\n","comments":"","group":"text"},"danton_text_check":{"type":"function","file":"danton/recorder/text.h","line":71,"lineto":71,"args":[{"name":"recorder","type":"struct danton_recorder *","comment":null}],"argline":"struct danton_recorder *recorder","sig":"struct danton_recorder *","return":{"type":"int","comment":"<pre><code>     `1` if the recorder is a text one, `0` otherwise.\n</code></pre>\n"},"description":"<p>Check if a danton_recorder is of <em>text</em> type.</p>\n","comments":"","group":"text"}},"callbacks":{"danton_primary_cb":{"type":"callback","file":"danton.h","line":66,"lineto":67,"args":[{"name":"primary","type":"struct danton_primary *","comment":"Handle for the primary data.\n"},{"name":"energy","type":"double","comment":"The energy of the primary neutrino, in GeV.\n"}],"argline":"struct danton_primary *primary, double energy","sig":"struct danton_primary *::double","return":{"type":"double","comment":"<pre><code>      The corresponding flux.\n</code></pre>\n"},"description":"<p>Callback for a primary neutrino flux.</p>\n","comments":""},"danton_event_cb":{"type":"callback","file":"danton.h","line":170,"lineto":171,"args":[{"name":"context","type":"struct danton_context *","comment":"Handle for the simulation context.\n"},{"name":"recorder","type":"struct danton_recorder *","comment":"Handle for the recorder data.\n"},{"name":"event","type":"const struct danton_event *","comment":"Handle for the event data.\n"}],"argline":"struct danton_context *context, struct danton_recorder *recorder, const struct danton_event *event","sig":"struct danton_context *::struct danton_recorder *::const struct danton_event *","return":{"type":"int","comment":"<pre><code>       `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Callback for recording a sampled event.</p>\n","comments":""},"danton_grammage_cb":{"type":"callback","file":"danton.h","line":180,"lineto":181,"args":[{"name":"context","type":"struct danton_context *","comment":"Handle for the simulation context.\n"},{"name":"recorder","type":"struct danton_recorder *","comment":"Handle for the recorder data.\n"},{"name":"grammage","type":"const struct danton_grammage *","comment":"Handle for the grammage data.\n"}],"argline":"struct danton_context *context, struct danton_recorder *recorder, const struct danton_grammage *grammage","sig":"struct danton_context *::struct danton_recorder *::const struct danton_grammage *","return":{"type":"int","comment":"<pre><code>      `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Callback for recording a grammage value.</p>\n","comments":""},"danton_run_cb":{"type":"callback","file":"danton.h","line":214,"lineto":215,"args":[{"name":"context","type":"struct danton_context *","comment":"Handle for the simulation context.\n"},{"name":"event","type":"enum danton_run_event","comment":"Flag signing the occuring event.\n"},{"name":"medium","type":"int","comment":null},{"name":"state","type":"struct danton_state *","comment":"The current particle state.\n"}],"argline":"struct danton_context *context, enum danton_run_event event, int medium, struct danton_state *state","sig":"struct danton_context *::enum danton_run_event::int::struct danton_state *","return":{"type":"int","comment":"<pre><code>     `EXIT_SUCCESS` on success, `EXIT_FAILURE` otherwise.\n</code></pre>\n"},"description":"<p>Callback for custom run actions.</p>\n","comments":""},"danton_lock_cb":{"type":"callback","file":"danton.h","line":295,"lineto":295,"args":[],"argline":"","sig":"","return":{"type":"int","comment":"<code>EXIT_SUCCESS</code> on success, <code>EXIT_FAILURE</code> otherwise.\n"},"description":"<p>Generic lock or unlock callback.</p>\n","comments":"<p class=\"longComment\">For multithreaded usage the user must supply a pair of lock and unlock callbacks ensuring exclusive access to critical data by the simulation contexts.</p>\n"}},"globals":{},"types":[["danton_context",{"decl":["enum danton_mode mode","int longitudinal","int decay","struct danton_primary *[6] primary","struct danton_sampler * sampler","struct danton_recorder * recorder","danton_run_cb * run_action"],"type":"struct","value":"danton_context","file":"danton.h","line":236,"lineto":284,"tdef":null,"description":" Handle for a simulation context.","comments":"<p class=\"longComment\">This structure is a proxy to thread specific simulation data. It exposes some public data that the user may configure or alter directly. However, it also encloses other opaque data. Therefore, it <strong>must</strong> be initialised and released with the <code>danton_context</code> functions.</p>\n","fields":[{"type":"enum danton_mode","name":"mode","comments":"The run mode. \n"},{"type":"int","name":"longitudinal","comments":"Flag for controlling the tranverse transport.\n\nSet this flag to <code>1</code> in order to disable tranverse transport, i.e.\n force straight trajectories. By default the transverse transport is\n enabled.\n"},{"type":"int","name":"decay","comments":"Flag for controlling the decay of tau final states.\n\nSet this flag to <code>1</code> if the sampled tau final states must be decayed.\n By default the taus are decayed.\n"},{"type":"struct danton_primary *[6]","name":"primary","comments":"Array of pointers to the primary flux models for each neutrino\n flavour.\n\nSet an entry to <code>ǸULL</code> in order to disable the corresponding\n neutrino as a primary. <strong>Note</strong> that in Monte-Carlo modes (Forward,\n or Backward) at least one entry <strong>must</strong> be non `ǸULL.\n"},{"type":"struct danton_sampler *","name":"sampler","comments":"Handle for the event sampler.\n\nStarts initialised to <code>ǸULL</code>. One must provide a sampler before\n running.\n"},{"type":"struct danton_recorder *","name":"recorder","comments":"Handle for the event recorder.\n\nStarts initialised to <code>ǸULL</code>. One must provide a recorder before\n running.\n"},{"type":"danton_run_cb *","name":"run_action","comments":"Callback for custom run action(s).\n\nStarts initialised to <code>ǸULL</code>, i.e. disabled. Providing additional\n run action(s) is optionnal.\n"}],"block":"enum danton_mode mode\nint longitudinal\nint decay\nstruct danton_primary *[6] primary\nstruct danton_sampler * sampler\nstruct danton_recorder * recorder\ndanton_run_cb * run_action","used":{"returns":["danton_context_create"],"needs":["danton_context_destroy","danton_error_count","danton_error_pop","danton_error_push","danton_event_cb","danton_get_uniform01","danton_grammage_cb","danton_run","danton_run_cb"]}}],["danton_discrete",{"decl":[],"type":"struct","value":"danton_discrete","file":"danton/primary/discrete.h","line":35,"lineto":35,"tdef":null,"description":" Opaque structure for a discrete danton_primary. ","comments":"","fields":[],"used":{"returns":["danton_discrete_create"],"needs":["danton_discrete_get","danton_discrete_set"]}}],["danton_event",{"decl":["long id","double weight","struct danton_state * primary","int generation","struct danton_state * vertex","struct danton_state * final","int n_products","struct danton_product * product"],"type":"struct","value":"danton_event","file":"danton.h","line":130,"lineto":151,"block":"long id\ndouble weight\nstruct danton_state * primary\nint generation\nstruct danton_state * vertex\nstruct danton_state * final\nint n_products\nstruct danton_product * product","tdef":null,"description":" Data container for exposing a recorded event. ","comments":"","fields":[{"type":"long","name":"id","comments":"The Monte-Carlo index of the event. \n"},{"type":"double","name":"weight","comments":"The Monte-Carlo weight for the event. \n"},{"type":"struct danton_state *","name":"primary","comments":"Pointer to the primary state. \n"},{"type":"int","name":"generation","comments":"The generation index of the recorded tau. An index &gt; 1 indicates\n that the tau originates from a regenerated neutrino, not from a\n primary one.\n"},{"type":"struct danton_state *","name":"vertex","comments":"Pointer to the tau state at its creation vertex. \n"},{"type":"struct danton_state *","name":"final","comments":"Pointer to the final particle state, before decay for taus. \n"},{"type":"int","name":"n_products","comments":"The number of decay products. \n"},{"type":"struct danton_product *","name":"product","comments":"Array of decay products. \n"}],"used":{"returns":[],"needs":["danton_event_cb"]}}],["danton_grammage",{"decl":["double elevation","double value"],"type":"struct","value":"danton_grammage","file":"danton.h","line":154,"lineto":159,"block":"double elevation\ndouble value","tdef":null,"description":" Data container for exposing a grammage computation. ","comments":"","fields":[{"type":"double","name":"elevation","comments":"The elevation angle of observation, in deg. \n"},{"type":"double","name":"value","comments":"The corresponding grammage value, in kg/m<sup>3.</sup> \n"}],"used":{"returns":[],"needs":["danton_grammage_cb"]}}],["danton_mode",{"decl":["DANTON_MODE_BACKWARD","DANTON_MODE_FORWARD","DANTON_MODE_GRAMMAGE","DANTON_MODE_N"],"type":"enum","file":"danton.h","line":218,"lineto":227,"block":"DANTON_MODE_BACKWARD\nDANTON_MODE_FORWARD\nDANTON_MODE_GRAMMAGE\nDANTON_MODE_N","tdef":null,"description":" The available run modes. ","comments":"","fields":[{"type":"int","name":"DANTON_MODE_BACKWARD","comments":"<p class=\"longComment\">Backward Monte-Carlo simulation. </p>\n","value":0},{"type":"int","name":"DANTON_MODE_FORWARD","comments":"<p class=\"longComment\">Classical forward Monte-Carlo. </p>\n","value":1},{"type":"int","name":"DANTON_MODE_GRAMMAGE","comments":"<p class=\"longComment\">Grammage computation. </p>\n","value":2},{"type":"int","name":"DANTON_MODE_N","comments":"<p class=\"longComment\">The total number of run modes. </p>\n","value":3}],"used":{"returns":[],"needs":[]}}],["danton_particle",{"decl":["DANTON_PARTICLE_UNKNOWN","DANTON_PARTICLE_NU_BAR_TAU","DANTON_PARTICLE_NU_BAR_MU","DANTON_PARTICLE_NU_BAR_E","DANTON_PARTICLE_NU_E","DANTON_PARTICLE_NU_MU","DANTON_PARTICLE_NU_TAU","DANTON_PARTICLE_N_NU","DANTON_PARTICLE_TAU_BAR","DANTON_PARTICLE_TAU","DANTON_PARTICLE_N"],"type":"enum","file":"danton.h","line":33,"lineto":56,"block":"DANTON_PARTICLE_UNKNOWN\nDANTON_PARTICLE_NU_BAR_TAU\nDANTON_PARTICLE_NU_BAR_MU\nDANTON_PARTICLE_NU_BAR_E\nDANTON_PARTICLE_NU_E\nDANTON_PARTICLE_NU_MU\nDANTON_PARTICLE_NU_TAU\nDANTON_PARTICLE_N_NU\nDANTON_PARTICLE_TAU_BAR\nDANTON_PARTICLE_TAU\nDANTON_PARTICLE_N","tdef":null,"description":" Indices of DANTON particles. ","comments":"","fields":[{"type":"int","name":"DANTON_PARTICLE_UNKNOWN","comments":"","value":-1},{"type":"int","name":"DANTON_PARTICLE_NU_BAR_TAU","comments":"<p class=\"longComment\">The anti tau neutrino. </p>\n","value":0},{"type":"int","name":"DANTON_PARTICLE_NU_BAR_MU","comments":"<p class=\"longComment\">The anti muon neutrino. </p>\n","value":1},{"type":"int","name":"DANTON_PARTICLE_NU_BAR_E","comments":"<p class=\"longComment\">The anti electron neutrino. </p>\n","value":2},{"type":"int","name":"DANTON_PARTICLE_NU_E","comments":"<p class=\"longComment\">The electron neutrino. </p>\n","value":3},{"type":"int","name":"DANTON_PARTICLE_NU_MU","comments":"<p class=\"longComment\">The muon neutrino. </p>\n","value":4},{"type":"int","name":"DANTON_PARTICLE_NU_TAU","comments":"<p class=\"longComment\">The tau neutrino. </p>\n","value":5},{"type":"int","name":"DANTON_PARTICLE_N_NU","comments":"<p class=\"longComment\">The total number of neutrino indices. </p>\n","value":6},{"type":"int","name":"DANTON_PARTICLE_TAU_BAR","comments":"<p class=\"longComment\">The anti tau. </p>\n","value":6},{"type":"int","name":"DANTON_PARTICLE_TAU","comments":"<p class=\"longComment\">The tau. </p>\n","value":7},{"type":"int","name":"DANTON_PARTICLE_N","comments":"<p class=\"longComment\">The total number of indices. </p>\n","value":8}],"used":{"returns":["danton_particle_index"],"needs":["danton_particle_pdg"]}}],["danton_primary",{"decl":["danton_primary_cb * flux","double [2] energy"],"type":"struct","value":"danton_primary","file":"danton.h","line":75,"lineto":80,"tdef":null,"description":" Base data for a primary flux model.","comments":"<p class=\"longComment\">This is the minimalistic representation of a primary neutrino flux. Any model implementation should conform to this.</p>\n","fields":[{"type":"danton_primary_cb *","name":"flux","comments":"The primary flux callback. \n"},{"type":"double [2]","name":"energy","comments":"The energy range over which the model is defined, in GeV. \n"}],"block":"danton_primary_cb * flux\ndouble [2] energy","used":{"returns":[],"needs":["danton_discrete_check","danton_powerlaw_check","danton_primary_cb"]}}],["danton_product",{"decl":["int pid","double [3] momentum"],"type":"struct","value":"danton_product","file":"danton.h","line":122,"lineto":127,"block":"int pid\ndouble [3] momentum","tdef":null,"description":" Data container for a tau decay product. ","comments":"","fields":[{"type":"int","name":"pid","comments":"The PDG ID of the daughter. \n"},{"type":"double [3]","name":"momentum","comments":"The 3-momentum of the daughter, in GeV/c. \n"}],"used":{"returns":[],"needs":[]}}],["danton_recorder",{"decl":["danton_event_cb * record_event","danton_grammage_cb * record_grammage"],"type":"struct","value":"danton_recorder","file":"danton.h","line":189,"lineto":192,"tdef":null,"description":" Base data for recording the sampled events or grammage computations.","comments":"<p class=\"longComment\">This is the minimalistic representation of an event recorder. Any concrete implementation should conform to this.</p>\n","fields":[{"type":"danton_event_cb *","name":"record_event","comments":""},{"type":"danton_grammage_cb *","name":"record_grammage","comments":""}],"block":"danton_event_cb * record_event\ndanton_grammage_cb * record_grammage","used":{"returns":[],"needs":["danton_event_cb","danton_grammage_cb","danton_text_check"]}}],["danton_run_event",{"decl":["DANTON_RUN_EVENT_START","DANTON_RUN_EVENT_STOP","DANTON_RUN_EVENT_STEP","DANTON_RUN_N"],"type":"enum","file":"danton.h","line":195,"lineto":204,"block":"DANTON_RUN_EVENT_START\nDANTON_RUN_EVENT_STOP\nDANTON_RUN_EVENT_STEP\nDANTON_RUN_N","tdef":null,"description":" Flags for events occuring during custom run action(s). ","comments":"","fields":[{"type":"int","name":"DANTON_RUN_EVENT_START","comments":"<p class=\"longComment\">Flag for the start of a new event. </p>\n","value":0},{"type":"int","name":"DANTON_RUN_EVENT_STOP","comments":"<p class=\"longComment\">Flag for the end of the current event. </p>\n","value":1},{"type":"int","name":"DANTON_RUN_EVENT_STEP","comments":"<p class=\"longComment\">Flag for a new step in the current event. </p>\n","value":2},{"type":"int","name":"DANTON_RUN_N","comments":"<p class=\"longComment\">The total number of event flags. </p>\n","value":3}],"used":{"returns":[],"needs":["danton_run_cb"]}}],["danton_sampler",{"decl":["double latitude","double longitude","double [2] altitude","double [2] azimuth","double [2] elevation","double [2] energy","double [8] weight"],"type":"struct","value":"danton_sampler","file":"danton.h","line":89,"lineto":107,"block":"double latitude\ndouble longitude\ndouble [2] altitude\ndouble [2] azimuth\ndouble [2] elevation\ndouble [2] energy\ndouble [8] weight","tdef":null,"description":" Data container for an event sampler.","comments":"<p class=\"longComment\">This structure specifies the final state of the events to sample. Once filled one <strong>must</strong> call <a href=\"./#v0.2.1/group/sampler/danton_sampler_update\">danton_sampler_update</a> for the sampler to be ready to use.</p>\n","fields":[{"type":"double","name":"latitude","comments":"The latitude at which events are sampled, in deg. \n"},{"type":"double","name":"longitude","comments":"The longitude at which events are sampled, in deg. \n"},{"type":"double [2]","name":"altitude","comments":"The altitude range over which events are sampled, in m. \n"},{"type":"double [2]","name":"azimuth","comments":"The azimuth angle range of the final state, in deg. \n"},{"type":"double [2]","name":"elevation","comments":"The elevation angle range of the final state, in deg. \n"},{"type":"double [2]","name":"energy","comments":"The energy range of the final state, in GeV. \n"},{"type":"double [8]","name":"weight","comments":"A weight vector specifying the sampling probabilities, in [0,1],\n for all particles.\n"}],"used":{"returns":["danton_sampler_create"],"needs":["danton_sampler_update"]}}],["danton_state",{"decl":["int pid","double energy","double [3] position","double [3] direction"],"type":"struct","value":"danton_state","file":"danton.h","line":110,"lineto":119,"block":"int pid\ndouble energy\ndouble [3] position\ndouble [3] direction","tdef":null,"description":" Data container for a recorded particle state. ","comments":"","fields":[{"type":"int","name":"pid","comments":"The PDG ID of the recorded particle.  \n"},{"type":"double","name":"energy","comments":"The total energy of the recorded particle, in GeV. \n"},{"type":"double [3]","name":"position","comments":"The ECEF position of the recorded particle, in m. \n"},{"type":"double [3]","name":"direction","comments":"The momentum&#39;s direction of the recorded particle, in ECEF frame. \n"}],"used":{"returns":[],"needs":["danton_run_cb"]}}],["danton_text_mode",{"decl":["DANTON_TEXT_MODE_APPEND","DANTON_TEXT_MODE_CREATE","DANTON_TEXT_MODE_N"],"type":"enum","file":"danton/recorder/text.h","line":35,"lineto":42,"block":"DANTON_TEXT_MODE_APPEND\nDANTON_TEXT_MODE_CREATE\nDANTON_TEXT_MODE_N","tdef":null,"description":" Operations mode for a text danton_recorder. ","comments":"","fields":[{"type":"int","name":"DANTON_TEXT_MODE_APPEND","comments":"<p class=\"longComment\">Append to an existing text file, or create it. </p>\n","value":0},{"type":"int","name":"DANTON_TEXT_MODE_CREATE","comments":"<p class=\"longComment\">Create a new text file, or override it. </p>\n","value":1},{"type":"int","name":"DANTON_TEXT_MODE_N","comments":"<p class=\"longComment\">The number of operations modes.  </p>\n","value":2}],"used":{"returns":[],"needs":[]}}]],"prefix":"include","groups":[["context",["danton_context_create","danton_context_destroy"]],["danton",["danton_destroy","danton_finalise","danton_initialise","danton_run"]],["discrete",["danton_discrete_check","danton_discrete_create","danton_discrete_get","danton_discrete_set"]],["earth",["danton_earth_model"]],["error",["danton_error_count","danton_error_pop","danton_error_push"]],["get",["danton_get_datum","danton_get_uniform01"]],["particle",["danton_particle_index","danton_particle_pdg"]],["powerlaw",["danton_powerlaw_check","danton_powerlaw_create"]],["sampler",["danton_sampler_create","danton_sampler_update"]],["text",["danton_text_check","danton_text_create"]]]}